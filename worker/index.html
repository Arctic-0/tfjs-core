<script src="https://unpkg.com/@tensorflow/tfjs-core@0.15.3/dist/tf-core.js"></script>

<button onclick="compute();">Compute</button>
<script>
function makeWorkers(n) {
  const workers = [];
  for (let i = 0; i < n; i++) {
    workers.push(new Worker('worker.js'));
  }
  return workers;
}

function computeOffsets(n, numSplits) {
  const offsets = [];
  const modulo = n % numSplits;
  let offset = 0;
  for (let i = 0; i < numSplits; i++) {
    offsets.push(offset);
    offset += Math.floor(n / numSplits);
    if (i < modulo) {
      offset++;
    }
  }
  return offsets;
}

async function matmul(a, b) {
  const aSize = a.shape[0];
  const bSize = b.shape[1];
  const k = a.shape[1];

  const nWorkers = 4;
  const workers = makeWorkers(nWorkers);
  const offsets = computeOffsets(aSize, nWorkers);
  const aVals = a.dataSync();
  const bVals = b.dataSync();

  const res = tf.zeros([aSize, bSize]);
  const resVals = res.dataSync();
  let count = 0;
  return new Promise(resolve => {
    workers.forEach((worker, i) => {
      worker.onmessage = function(e) {
        const offset = offsets[i] * bSize;
        resVals.set(e.data, offset);
        count++;
        if (count === nWorkers) {
          resolve(res);
        }
      };
      const offset = offsets[i] * k;
      const nextOffset = i + 1 < offsets.length ? offsets[i + 1] * k : undefined;
      const aSubVals = aVals.slice(offset, nextOffset);
      const bValsCopy = bVals.slice();
      worker.postMessage([aSubVals.buffer, bValsCopy.buffer, k], [aSubVals.buffer, bValsCopy.buffer]);
    });
  });
}

tf.setBackend('cpu');

async function compute() {
  const N = 1024;
  const a = tf.randomUniform([N, N]);
  const b = tf.randomUniform([N, N]);

  let start = performance.now();
  const res = tf.matMul(a, b);
  console.log('tf.js took', performance.now() - start);

  start = performance.now();
  const res2 = await matmul(a, b);
  console.log('worker took', performance.now() - start);
  tf.test_util.expectArraysClose(res, res2);
}
</script>
